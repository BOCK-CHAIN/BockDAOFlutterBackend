[
  {
    "projectId": "fd51fe89-26e7-4e1e-a765-f966a6dd8e54",
    "testId": "a8429772-7a01-4652-937f-12a96db52249",
    "userId": "0448d408-20a1-705f-dda1-6090508eca70",
    "title": "TC001-get_block_by_hashorid",
    "description": "Verify that the API endpoint GET /block/{hashorid} correctly returns block information when provided with a valid block hash or height. Test with valid, invalid, and non-existent hashorid values.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\nHEADERS = {\n    \"Accept\": \"application/json\"\n}\n\ndef test_get_block_by_hashorid():\n    \"\"\"\n    Test GET /block/{hashorid} endpoint for:\n    - Valid block height (integer as string)\n    - Valid block hash (string)\n    - Invalid hashorid (incorrect format)\n    - Non-existent hashorid (valid format but no corresponding block)\n    \"\"\"\n    # 1. First, get a valid block hash or height by retrieving the genesis block or latest block.\n    # Since no direct \"/block/latest\" in doc, try \"0\" height assuming Genesis block is 0.\n    valid_height = \"0\"\n    valid_block_hash = None\n\n    try:\n        # Get block by height 0 (likely genesis block)\n        resp = requests.get(f\"{BASE_URL}/block/{valid_height}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Expected 200 for valid height {valid_height}, got {resp.status_code}\"\n        block_data = resp.json()\n        assert isinstance(block_data, dict), \"Response is not a JSON object\"\n        \n        # Extract block hash if present in response (heuristic keys)\n        # Try common keys: 'hash', 'block_hash', or present top level key that looks like hash\n        for key in [\"hash\", \"block_hash\", \"id\"]:\n            if key in block_data and isinstance(block_data[key], str):\n                valid_block_hash = block_data[key]\n                break\n        # If no hash found, fallback to first string value in block data with length >= 20 (typical hash length)\n        if not valid_block_hash:\n            for v in block_data.values():\n                if isinstance(v, str) and len(v) >= 20:\n                    valid_block_hash = v\n                    break\n\n    except Exception as e:\n        raise AssertionError(f\"Failed to retrieve block by valid height {valid_height}: {e}\")\n\n    # 2. Test GET block by valid block hash if found\n    if valid_block_hash:\n        resp = requests.get(f\"{BASE_URL}/block/{valid_block_hash}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Expected 200 for valid block hash {valid_block_hash}, got {resp.status_code}\"\n        block_data_hash = resp.json()\n        assert isinstance(block_data_hash, dict), \"Response for block hash is not a JSON object\"\n    else:\n        # No valid block hash found, log but continue testing other cases\n        print(\"Warning: No valid block hash extracted from block data to test GET by hash.\")\n\n    # 3. Test GET block with invalid hashorid (e.g. invalid format string)\n    invalid_hashorid = \"!!!invalid_hash@@@\"\n    resp = requests.get(f\"{BASE_URL}/block/{invalid_hashorid}\", headers=HEADERS, timeout=TIMEOUT)\n    # We expect client or server error, commonly 400 or 404\n    assert resp.status_code in (400, 404), f\"Expected 400 or 404 for invalid hashorid, got {resp.status_code}\"\n\n    # 4. Test GET block with non-existent but valid hashorid\n    # A valid numeric height string that likely does not exist (e.g. 9999999) or valid hash format but no block\n    non_existent_height = \"9999999\"\n    resp = requests.get(f\"{BASE_URL}/block/{non_existent_height}\", headers=HEADERS, timeout=TIMEOUT)\n    # Accept either 400 or 404 for non-existent block\n    assert resp.status_code in (400, 404), f\"Expected 400 or 404 for non-existent height {non_existent_height}, got {resp.status_code}\"\n\n    if valid_block_hash:\n        non_existent_hash = valid_block_hash[:-1] + (\"0\" if valid_block_hash[-1] != \"0\" else \"1\")\n        resp = requests.get(f\"{BASE_URL}/block/{non_existent_hash}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code in (400, 404), f\"Expected 400 or 404 for non-existent hash {non_existent_hash}, got {resp.status_code}\"\n\ntest_get_block_by_hashorid()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-28T13:22:24.910Z",
    "modified": "2025-08-28T13:23:21.750Z"
  },
  {
    "projectId": "fd51fe89-26e7-4e1e-a765-f966a6dd8e54",
    "testId": "7ab4aa8b-5d8a-48a8-aadf-31ef9db2d19e",
    "userId": "0448d408-20a1-705f-dda1-6090508eca70",
    "title": "TC002-get_transaction_by_hash",
    "description": "Verify that the API endpoint GET /tx/{hash} returns the correct transaction information for a valid transaction hash. Test with valid, invalid, and non-existent transaction hashes.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\n\ndef test_get_transaction_by_hash():\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    # Use a valid 64-char hex string as a valid transaction hash placeholder\n    valid_tx_hash = \"a\" * 64\n\n    # 1) Test valid transaction hash format\n    url_valid = f\"{BASE_URL}/tx/{valid_tx_hash}\"\n    resp_valid = requests.get(url_valid, headers=headers, timeout=TIMEOUT)\n    # Expect 200 OK or 404 Not Found\n    assert resp_valid.status_code in {200, 404}, f\"Expected status 200 or 404 for valid tx hash, got {resp_valid.status_code}\"\n\n    if resp_valid.status_code == 200:\n        data_valid = resp_valid.json()\n        # Basic validations on returned transaction info\n        assert isinstance(data_valid, dict), \"Transaction info should be a JSON object\"\n        # Due to PRD no guarantee of 'hash' field, only assert it's a string if present\n        if \"hash\" in data_valid:\n            assert isinstance(data_valid[\"hash\"], str), \"Returned hash field should be a string\"\n\n        # Additional fields presence (based on typical transaction, no full schema provided)\n        assert any(k in data_valid for k in [\"block_hash\", \"from\", \"to\", \"amount\"]), \"Expected transaction fields missing\"\n\n    # 2) Test invalid transaction hash (bad format)\n    invalid_hash = \"!!!invalidhash@@@\"\n    url_invalid = f\"{BASE_URL}/tx/{invalid_hash}\"\n    resp_invalid = requests.get(url_invalid, headers=headers, timeout=TIMEOUT)\n    # Expect client error status for invalid tx hash\n    assert resp_invalid.status_code in {400, 404, 422}, f\"Expected client error status for invalid tx hash, got {resp_invalid.status_code}\"\n\n    # 3) Test non-existent but well-formed transaction hash\n    non_existent_hash = \"f\" * 64\n    url_nonexist = f\"{BASE_URL}/tx/{non_existent_hash}\"\n    resp_nonexist = requests.get(url_nonexist, headers=headers, timeout=TIMEOUT)\n    # Expect 404 Not Found or similar indicating no transaction found\n    assert resp_nonexist.status_code == 404, f\"Expected 404 for non-existent tx hash, got {resp_nonexist.status_code}\"\n\n\ntest_get_transaction_by_hash()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 46, in <module>\n  File \"<string>\", line 18, in test_get_transaction_by_hash\nAssertionError: Expected status 200 or 404 for valid tx hash, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-28T13:22:24.917Z",
    "modified": "2025-08-28T13:23:39.233Z"
  },
  {
    "projectId": "fd51fe89-26e7-4e1e-a765-f966a6dd8e54",
    "testId": "a9b312ac-2091-44d9-9675-a08265c24e7f",
    "userId": "0448d408-20a1-705f-dda1-6090508eca70",
    "title": "TC004-get_all_governance_proposals",
    "description": "Verify that the API endpoint GET /dao/proposals returns a list of all governance proposals with correct data structure and content.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef test_get_all_governance_proposals():\n    \"\"\"\n    Test GET /dao/proposals returns a list of all governance proposals with correct data structure and content.\n    If no proposals exist, create a test proposal, verify inclusion, then delete it.\n    \"\"\"\n    proposal_create_url = f\"{BASE_URL}/dao/proposal\"\n    proposals_url = f\"{BASE_URL}/dao/proposals\"\n\n    # Sample proposal data for creation\n    new_proposal_payload = {\n        \"title\": \"Test Proposal - Governance API Validation\",\n        \"description\": \"Proposal created for testing GET /dao/proposals endpoint\",\n        \"proposal_type\": \"general\",\n        \"voting_type\": \"token-based\",\n        \"duration\": 3600,      # 1 hour\n        \"threshold\": 50,\n        # Private key is required for authenticated actions; use a dummy key for test (assumed accepted in test env)\n        \"private_key\": \"test_private_key_1234567890abcdef\"\n    }\n\n    created_proposal_id = None\n\n    try:\n        # Step 1: Get existing proposals\n        response = requests.get(proposals_url, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200 OK from {proposals_url}, got {response.status_code}\"\n        proposals = response.json()\n        assert isinstance(proposals, list), \"/dao/proposals response is not a list\"\n\n        # If there are proposals already, verify structure of the first few items (if any)\n        if proposals:\n            for proposal in proposals[:5]:\n                assert isinstance(proposal, dict), \"Proposal item is not a dictionary\"\n                # Check presence and type of key fields\n                assert \"id\" in proposal and isinstance(proposal[\"id\"], str), \"Proposal missing 'id' or it is not a string\"\n                assert \"title\" in proposal and isinstance(proposal[\"title\"], str), \"Proposal missing 'title' or it is not a string\"\n                assert \"description\" in proposal and isinstance(proposal[\"description\"], str), \"Proposal missing 'description' or it is not a string\"\n                assert \"proposal_type\" in proposal and isinstance(proposal[\"proposal_type\"], str), \"Proposal missing 'proposal_type' or it is not a string\"\n                assert \"voting_type\" in proposal and isinstance(proposal[\"voting_type\"], str), \"Proposal missing 'voting_type' or it is not a string\"\n                assert \"duration\" in proposal and isinstance(proposal[\"duration\"], int), \"Proposal missing 'duration' or it is not an int\"\n                assert \"threshold\" in proposal and isinstance(proposal[\"threshold\"], int), \"Proposal missing 'threshold' or it is not an int\"\n            return  # Test passed with existing proposals\n\n        # Step 2: No proposals found, create one\n        create_response = requests.post(proposal_create_url, json=new_proposal_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert create_response.status_code == 200, f\"Expected 200 OK from {proposal_create_url}, got {create_response.status_code}\"\n        create_resp_json = create_response.json()\n        assert isinstance(create_resp_json, dict), \"Response from creating proposal is not a JSON object\"\n        created_proposal_id = create_resp_json.get(\"id\")\n        assert created_proposal_id and isinstance(created_proposal_id, str), \"Created proposal response missing valid 'id'\"\n\n        # Sleep briefly to ensure proposal is indexed/available\n        time.sleep(1)\n\n        # Step 3: Get proposals again, verify newly created proposal is included\n        response_after_create = requests.get(proposals_url, headers=HEADERS, timeout=TIMEOUT)\n        assert response_after_create.status_code == 200, f\"Expected 200 OK on second GET from {proposals_url}, got {response_after_create.status_code}\"\n        proposals_after_create = response_after_create.json()\n        assert isinstance(proposals_after_create, list), \"/dao/proposals response after create is not a list\"\n\n        ids = [p.get(\"id\") for p in proposals_after_create if isinstance(p, dict)]\n        assert created_proposal_id in ids, \"Created proposal ID not found in list of proposals after creation\"\n\n        for proposal in proposals_after_create:\n            if proposal.get(\"id\") == created_proposal_id:\n                # Verify fields match creation payload\n                assert proposal.get(\"title\") == new_proposal_payload[\"title\"], \"Proposal title mismatch\"\n                assert proposal.get(\"description\") == new_proposal_payload[\"description\"], \"Proposal description mismatch\"\n                assert proposal.get(\"proposal_type\") == new_proposal_payload[\"proposal_type\"], \"Proposal type mismatch\"\n                assert proposal.get(\"voting_type\") == new_proposal_payload[\"voting_type\"], \"Voting type mismatch\"\n                assert isinstance(proposal.get(\"duration\"), int), \"Proposal duration is missing or not int\"\n                assert isinstance(proposal.get(\"threshold\"), int), \"Proposal threshold is missing or not int\"\n                break\n        else:\n            assert False, \"Created proposal not found in proposals list after creation\"\n\n    finally:\n        # Cleanup: delete the created proposal if possible\n        # Note: No delete endpoint provided in PRD, so no delete step possible.\n        # If deletion endpoint existed, we would attempt cleanup here.\n        pass\n\ntest_get_all_governance_proposals()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 93, in <module>\n  File \"<string>\", line 56, in test_get_all_governance_proposals\nAssertionError: Expected 200 OK from http://localhost:9000/dao/proposal, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-28T13:22:24.922Z",
    "modified": "2025-08-28T13:23:59.681Z"
  },
  {
    "projectId": "fd51fe89-26e7-4e1e-a765-f966a6dd8e54",
    "testId": "57d7a04e-5c17-4e28-a3a6-6574a339ee8f",
    "userId": "0448d408-20a1-705f-dda1-6090508eca70",
    "title": "TC007-get_treasury_status_and_balance",
    "description": "Verify that the API endpoint GET /dao/treasury returns the current treasury status and balance accurately.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\nHEADERS = {\n    \"Accept\": \"application/json\"\n}\n\ndef test_get_treasury_status_and_balance():\n    url = f\"{BASE_URL}/dao/treasury\"\n    try:\n        response = requests.get(url, headers=HEADERS, timeout=TIMEOUT)\n        # Assert response code is 200 OK\n        assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n        data = response.json()\n        # Expected key in treasury status and balance\n        expected_keys = {\"balance\"}\n\n        # Assert all expected keys are present in response\n        missing_keys = expected_keys - data.keys()\n        assert not missing_keys, f\"Missing keys in treasury response: {missing_keys}\"\n\n        # Validate types and values (basic sanity checks)\n        assert (isinstance(data[\"balance\"], (int, float)) and data[\"balance\"] >= 0), \"Invalid treasury balance\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed with exception: {e}\"\n\ntest_get_treasury_status_and_balance()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-28T13:22:24.928Z",
    "modified": "2025-08-28T13:23:07.261Z"
  },
  {
    "projectId": "fd51fe89-26e7-4e1e-a765-f966a6dd8e54",
    "testId": "c1c825f7-7676-47c1-bf53-74f9feeca332",
    "userId": "0448d408-20a1-705f-dda1-6090508eca70",
    "title": "TC009-get_token_balance_for_address",
    "description": "Verify that the API endpoint GET /dao/token/balance/{address} returns the correct token balance for a given address.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\n\ndef test_get_token_balance_for_address():\n    \"\"\"\n    Test the GET /dao/token/balance/{address} endpoint for correctness.\n    This test will:\n    - Create a new token holder by transferring tokens to a new address\n    - Query the balance for that address and validate the expected balance\n    - Cleanup if necessary (not applicable here since token transfer is blockchain state)\n    \"\"\"\n    # For testing, we need a valid address. We'll create one by transferring tokens to a newly generated address.\n    # In real scenario, generating a wallet/address should be done properly; here we simulate a random test address.\n    import uuid\n    test_address = f\"testaddress_{uuid.uuid4().hex[:16]}\"  # synthetic test address\n\n    # We need to have tokens in this address to verify balance.\n    # For that, transfer tokens from a known address with private_key (we simulate it here).\n    # Use a predefined source address and private_key for testing (replace with valid test creds).\n    source_private_key = \"test_private_key_for_source\"  # Placeholder: Replace with valid key for actual testing\n    transfer_amount = 100\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Step 1: Transfer tokens to the test_address to ensure it has tokens\n    transfer_payload = {\n        \"to\": test_address,\n        \"amount\": transfer_amount,\n        \"private_key\": source_private_key\n    }\n    try:\n        transfer_response = requests.post(\n            f\"{BASE_URL}/dao/token/transfer\",\n            json=transfer_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert transfer_response.status_code == 200, f\"Token transfer failed: {transfer_response.text}\"\n\n        # Step 2: Query the token balance for the test_address\n        balance_response = requests.get(\n            f\"{BASE_URL}/dao/token/balance/{test_address}\",\n            timeout=TIMEOUT\n        )\n        assert balance_response.status_code == 200, f\"Balance fetch failed: {balance_response.text}\"\n\n        balance_data = balance_response.json()\n        # The API response structure is unknown, but expect a field named 'balance' or similar\n        assert \"balance\" in balance_data, f\"Response missing 'balance' field: {balance_data}\"\n        balance = balance_data[\"balance\"]\n        assert isinstance(balance, (int, float)), f\"Balance field is not a number: {balance}\"\n\n        # Validate that balance is at least the amount transferred\n        assert balance >= transfer_amount, f\"Balance {balance} less than transferred amount {transfer_amount}\"\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {str(e)}\"\n\ntest_get_token_balance_for_address()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 61, in <module>\n  File \"<string>\", line 40, in test_get_token_balance_for_address\nAssertionError: Token transfer failed: {\"Error\":\"invalid private key format\"}\n\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-28T13:22:24.934Z",
    "modified": "2025-08-28T13:23:02.127Z"
  }
]
